**认识正则**

其实就是字符串规则表达式

    <?php
    
    $str='hi this is a history';
    
    $patt='/hi/';
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);//array(1) { [0]=> array(3) { [0]=> string(2) "hi" [1]=> string(2) "hi" [2]=> string(2) "hi" } }
      ?>



$patt 就是正则表达式,$str是目标字符串,$src输出的字符串//数组形式

pre_match_all 输出正则表达式的函数

- 具体字符 (字面值)
- 字符边界
- 字符集合[ace],[01235689]
- 字符补集[^ qxz ]:不在qxz 范围内
- 字符范围[a-z0-9]
- 字符簇(系统定义好的常用集合)


字符边界

- ^ 匹配字符串的开始
- $ 匹配字符串的结尾
- \b 匹配单词的开始和结尾(边界)
- \B匹配单词的非边界


**常用字符簇**

![](http://i.imgur.com/Ao9o7ks.jpg)

**单词匹配**

    <?php
    
    $str='hi this is a history';
    
    $patt='/\bhi\b/';//找hi 这个单词
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src); //array(1) { [0]=> array(1) { [0]=> string(2) "hi" } }
      ?>


    <?php
    
    $str='hi this is a history';
    
    $patt='/\Bhi\B/';//找包含hi的单词
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src); //array(1) { [0]=> array(1) { [0]=> string(2) "hi" } }
      ?>


第二个结果一样是因为要找hi既不在单词的开始也不在结尾，只有this 符合

**集合与补集示例**

给定一组手机号，必须由[0123456789]组成的才选出来，从字符串的开始找，找到字符串的结束，用: ^ $

集合：

    <?php
    
    $arr = array('13800138000','13426060134','170235','18289881234568782');
    
    $patt='/^[01235689]{11}$/'; //{}找个数的意思
    foreach ($arr as $k => $v) {
    	preg_match_all($patt,$v, $res);
    	var_dump($res);
    }
      ?>


补集

    <?php
    
    $arr = array('13800138000','13426060134','170235','18289881234568782');
    
    $patt='/^[^47]{11}$/'; //{}找个数的意思
    foreach ($arr as $k => $v) {
    	preg_match_all($patt,$v, $res);
    	var_dump($res);
    }
      ?>


**字符范围**

    <?php
    
    $str='google baidu stackflou o2o ofo b2b ';
    
    $patt='/\b[a-z A-Z ]+\b/';//+ 表示无限个
    
	$patt='/\b[a-z A-Z ]{5,}\b/';//表示最少五个	

    preg_match_all($patt, $str, $src);
    
    var_dump($src);//array(1) { [0]=> array(2) { [0]=> string(23) "google baidu stackflou " [1]=> string(5) " ofo " } }
      ?>


**字符簇**

就是系统给定好的表达方式

    <?php
    
    $str = 'tommorw is another day , o2o , you dont bird me i dont bird you';
    
    $patt='/\W {1,}/';// \W 就是\w [a-z A-Z 0-9] 的补集
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
      ?>


用正则表达式执行搜索和替换

    <?php
    
    $str = 'tommorw  is  another  day ,  o2o ,  uou   ont  bird  me  i  dont  bird  you';
    
    $patt='/ \s{1,}/';//\s表示空白字符
    
    echo preg_replace($patt, '//', $str);
    
      ?>


输出tommorw//is//another//day ,//o2o ,//uou//ont//bird//me//i//dont//bird//you


**数量规则表达式**


*匹配前面的子表达式零次或多次。

+匹配前面的子表达式一次或多次。

\? 匹配前面的子表达式零次或一次。

{n} n 是一个非负整数。匹配确定的 n 次。

{n,m} m 和 n 均为非负整数，其中n <= m

最少匹配 n 次且最多匹配 m 次。。

{n,} n 是一个非负整数。至少匹配n 次。

**或者的用法**

    <?php
    
    // 查找纯数组或纯字母的词
    $str = 'hello o2o 2b9 250';
    
    $patt='/\b[a-z A-Z]+\b|\b[0-9]+\b/';// |表示或者的意思
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
    
      ?>


**贪婪与非贪婪**

正则默认是贪婪模式

    <?php
    
    $str = 'ksda good goooood good kl s ja dfs dk ';
    //找出以gK开头以d结尾的单词
    $patt='/g.+d/'; // g开头 .表示当中任意字符且不限制个数 d结尾,默认贪婪模式，会尽量多的匹配
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
    
      ?>

换成非贪婪模式

    <?php
    
    $str = 'ksda good goooood good kl s ja dfs dk ';
    //找出以gK开头以d结尾的单词
    $patt='/g.+?d/'; //在数量(+ * {n,}) 限定符后加? 就开启非贪婪模式
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
    
      ?>


采集手机号：

    <?php
    
    $str = '杨先生,卖洗衣机,13800138000, 备用电话18902587413, 
    QQ:258963,email:wang@qq.com, 身份证号:101101197912123039';
    
    //采集手机号
    
    $patt='/\b1[358]\d{9}\b/';
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
      ?>


**后向引用**

找首尾字母相同的单词

后向引用：第n个小括号内的子表达式，命中的内容，后面就\n来引用

    <?php
    
    $str = 'txt hello, high, bom , mum';
    
    $patt='/\b([a-z])\w+\1\b/'; //\1 表示第一次出现的小括号
    
    preg_match_all($patt, $str, $src);
    
    var_dump($src);
      ?>


把手机号中间4位替换为*

    <?php
    
    $str = '13800138000 , 13426060134 ';
    
    $patt='/\b(\d{3})\d{4}(\d{4})\b/';
    
    echo preg_replace($patt, '\1****\2', $str);//138****8000 , 134****0134
      ?>


**模式**

模式修饰符,可以一定程度上影响正则的解析行为

比如i, 就代表正则不区分大小写, /[a-z A-Z ]+/ --->/[a-z ]+/i

比如s, 单行模式, 就代表把整个文件看成一个"单行"

    $str = 'hello WORLD, ChINa';
    //$patt = '/\b[a-z]+\b/'; //hello
    $patt = '/\b[a-z]+\b/i'; # 忽略大小写
    preg_match_all($patt, $str, $matches);
    print_r($matches);
    $str = "abc haha
    abc dgh";
    $patt = '/.+/s'; # single 单行模式，将所有内容看成一行
    preg_match_all($patt, $str, $matches);
    print_r($matches);


正则表达式对中文的写法

u模式，把传入的参数看成是Unicode字符集的编码，可以判断中文

PHP下正则匹配中文 \x{4e00}-\x{9fa5}

    $str = 'bubble杨';
    $patt = '/^[\x{4e00}-\x{9fa5}]+$/u';
    echo preg_match($patt, $str) ? '纯中文' : '杂文'; //杂文


**预查**

    <?php
    //把ing结尾的单词词根部分（即不含ing部分）找出来
    $str = 'hello ,when i am working , don not coming';
    
    $patt = '/\b\w+(?=ing\b)/';
    preg_match_all($patt, $str, $matches);
    print_r($matches); //work com
    
    
    
    
    
      ?>


