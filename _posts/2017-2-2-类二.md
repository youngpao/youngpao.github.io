**单例模式**

类只能有一个对象

第一步：

    <?php 
    //step1 普通的single类
    class Single{
    	public $rand;
    	public function __construct(){
    		return $this->rand=mt_rand(1000,9999);
    	}
    }
    //两个实例化对象
    $a=new Single();
    $b=new Single();
    print_r($a);
    echo '<br/>';
    print_r($b); 
    ?>
    

第二步：

    <?php 
    //step2 实例化受保护不被调用
    class Single{
    	public $rand;
    	protected function __construct(){
    		return $this->rand=mt_rand(1000,9999);
    	}
    }
    //两个实例化对象
    $a=new Single();
    $b=new Single();
    print_r($a);
    echo '<br/>';
    print_r($b);  //报错，不能被调用
    ?>
    

第三步：

    <?php 
    //step3 静态方法调用受保护的构造方法
    class Single{
    	public $rand;
    	protected function __construct(){
    		 $this->rand=mt_rand(1000,9999);
    	}
    	static public function getNum(){
    		return new Single();
    	}
    }
    //两个实例化对象
    $a=Single::getNum();
    $b=Single::getNum();
    print_r($a);
    echo '<br/>';
    print_r($b);
    
    ?>
    

第四步：

    <?php 
    //step4 此时控制权已经转移，添加判断如果被实例化则返回该对象，没有则实例化再返回
    class Single{
    	public $rand;
    	static protected  $ins;
    	protected function __construct(){
    		 $this->rand=mt_rand(1000,9999);
    	}
    	static public function getNum(){
    		if (Single::$ins === null) {
    			Single::$ins =new Single();
    		}
    		return Single::$ins;
    	}
    }
    $a=Single::getNum();
    $b=Single::getNum();
    print_r($a);
    echo '<br/>';
    print_r($b); //返回相同值
    ?>
    
但是此时，如果用继承那么就还不是单例实例

    
    <?php 
    //step5 要用final 来使构造方法不可以被子继承
    class Single{
    	public $rand;
    	static protected  $ins;
    	//不允许被子继承
    	final protected function __construct(){
    		 $this->rand=mt_rand(1000,9999);
    	}
    	static public function getNum(){
    		if (Single::$ins === null) {
    			Single::$ins =new Single();
    		}
    		return Single::$ins;
    	}
    }
    $a=Single::getNum();
    $b=Single::getNum();
    print_r($a);
    echo '<br/>';
    print_r($b); //返回相同值
    ?>


