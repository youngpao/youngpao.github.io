**延迟绑定**

    <?php
    
    class Par{
    	public function a(){
    		echo 11;
    	}
    
    	public function b(){
    		$this->a();
    	}
    }
    
    class Son extends Par{
    	public function a(){
    		echo 22;
    	}
    }
    
    $son=new Son();
    $son->b();  //22
    
    ?>
    
子类继承父类，此时$son 这个对象等于$this ，然后调用son中的a

下面另一种情况

    <?php
    
    class Par{
    	public static function a(){
    		echo 11;
    	}
    
    	public  static function b(){
    		self ::a();
    	}
    }
    
    class Son extends Par{
    	public static function a(){
    		echo 22;
    	}
    }
    
    Son::b(); //11
    
    ?>
    

这是的son在父类中，调用的就是父类的a函数

但是修改一下

    <?php
    
    class Par{
    	public static function a(){
    		echo 11;
    	}
    	//延迟绑定
    	public  static function b(){
    		 static::a();
    	}
    }
    
    class Son extends Par{
    	public static function a(){
    		echo 22;
    	}
    }
    
    Son::b(); //22
    
    ?>
    

static 此时的作用是 在函数执行到  Son::b() 之前，static指的a函数是没有主人的a函数，谁调用就是谁的，所以son调用了， 那么就是son 的a函数

**超载的static**

static定义静态变量就是在局部区域内有效，当函数执行后的值不释放

因为static 使用频率太高，在定义静态变量、静态方法和静态属性、延迟绑定中都要用到
所以这样会分辨不清，要避免这种情况

**多态**

PHP语言中,不做参数的类型检测,可以传任意类型,

本身谈不上多态的.

在强类型语言中, 会检测参数的类型,

在声明时,可以声明参数的父类类型, 如Car,

具体的实参可以是Car型,以及Car的子类,这种现象就是多态.

php版本这样写在java中是报错，因为没有多态

    <?php
    class Car{
    
    }
    
    class BMW extends Car{
    	public function run(){
    		echo 'didi';
    	}
    }
    
    class QQ extends Car{
    	public function run(){
    		echo 'wuwu';
    	}
    }
    
    function drive($car){
    	$car->run();
    }
    
    drive($car=new BMW()); //didi
    ?>

**封装数据库类**

根据以下抽象类和接口的提示,继承并实现数据库类,分页类,上传类,图片处理类.

    <?php
    abstract class aDB {
     /**
     * 连接数据库，从配置文件读取配置信息
     */
     abstract public function conn();
     /**
     * 发送query查询
     * @param string $sql sql语句
     * @return mixed
     */
     abstract public function query($sql);
     /**
     * 查询多行数据
     * @param string $sql sql语句
     * @return array
     */
     abstract public function getAll($sql);
     /**
     *单行数据
     * @param string $sql sql语句
     * @return array
     */
     abstract public function getRow($sql);
     /**
     * 查询单个数据 如count(*)
     * @param string $sql sql语句
     * @return mixed
     */
     abstract public function getOne($sql);
     /**
     * 自动创建sql并执行
     * @param array $data 关联数组 键/值与表的列/值对应
     * @param string $table 表名字
     * @param string $act 动作update/insert
     * @param string $where 条件，用于update
     * @return int 新插入的行的主键值或影响行数
     */
     abstract public function Exec($data , $table , $act='insert' , $where='0');
     /**
     * 返回上一条insert语句产生的主键值
     */
     abstract public function lastId();
     /**
     *返回上一条语句影响的函数
     */
     abstract public function affectRows();
    }
    
    class Mysql extends aDB {
    	public $link;
    	public function __construct(){
    		$this->conn();
    	}
    	/**
     	* 连接数据库，从配置文件读取配置信息
     	*/
    	public function conn(){
    		$cfg=include './config.php';
    		$this->link=new mysqli($cfg['host'],$cfg['user'],$cfg['pwd'],$cfg['db']);
    		$this->query('set names'.$cfg['charset']);
    	}
    	/**
     	* 发送query查询
     	* @param string $sql sql语句
     	* @return mixed
     	*/
    	public function query($sql){
    		return $this->link->query($sql);
    	}
    	/**
     	* 查询多行数据
     	* @param string $sql sql语句
     	* @return array
     	*/
    	public function getAll($sql){
    		$daya=[];
    		$res=$this->query($sql);
    		while ($row=$res->fetch_assoc()) {
    			$data[]=$row;
    		}
    		return $data;
    	}
    	/**
     	*单行数据
     	* @param string $sql sql语句
     	* @return array
     	*/
    	public function getRow($sql){
    		$res=$this->query($sql);
    		$row=$res->fetch_assoc();
    		return $row;
    	}
    	/**
     	* 查询单个数据 如count(*)
     	* @param string $sql sql语句
     	* @return mixed
     	*/
    	public function getOne($sql){
    		$res=$this->query($sql);
    		$row=$res->fetch_row()[0];
    		return $row;
    	}
    	/**
     	* 自动创建sql并执行
     	* @param array $data 关联数组 键/值与表的列/值对应
     	* @param string $table 表名字
     	* @param string $act 动作update/insert
     	* @param string $where 条件，用于update
     	* @return int 新插入的行的主键值或影响行数
     	*/
    	public function Exec($data , $table , $act='insert' , $where='0'){
    		//判断动作
    		if ($act == 'insert') {
    			 $sql='insert into'.$table .'(';
    			 $sql.=implode(',',array_keys($data)).') ';
    			 $sql.='values (';
    			 $sql.=implode("','", array_values($data))."')";
    		}else{
    			//如果不是insert那就默认为update
    			$sql="update $table set";
    			foreach ($data as $k=> $v) {
    				$sql.=$k."='".$v."',";
    			}
    			$sql=rtrim($sql,',');
    			$sql.=" where $where";
    		}
    		return $this->query($sql);
    	}
    	/**
     	* 返回上一条insert语句产生的主键值
     	*/
    	public function lastId(){
    		return $this->link->inset_id;
    	}
    	/**
     	*返回上一条语句影响的函数
     	*/
    	public function affectRows(){
    		return $this->link->affected_rows;
    	}
    }
    
    $mysql=new Mysql();
    
    ?>
  

在config.php中

    <?php
    $cfg=array(
    	'host' => 'localhost',
    	'user' => 'root',
    	'pwd'  => '',
    	'db'   => 'test',
    	'charset' =>'utf8'
    	);
    
    return $cfg;
    
      ?>


**封装文件上传**

